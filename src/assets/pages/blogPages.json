[
  {
    "profile": { "date": "2024-10-06", "category": ["学习拓展"], "tag": ["IO", "select", "epoll"] },
    "htmlContent": "<h3><strong>1. 阻塞IO模型</strong></h3>\n<p><img src=\"@Img_IO/2024-07-08-17-29-41-image.png\" alt=\"\"></p>\n<p>进程发起IO系统调用后，进程被阻塞，转到内核空间处理，整个IO处理完毕后返回进程。操作成功则进程获取到数据。</p>\n<p><strong>1、典型应用：阻塞socket、Java BIO；</strong></p>\n<p><strong>2、特点：</strong></p>\n<ul>\n<li>进程阻塞挂起不消耗CPU资源，及时响应每个操作；</li>\n<li>实现难度低、开发应用较容易；</li>\n<li>适用并发量小的网络应用开发；</li>\n</ul>\n<p>不适用并发量大的应用：因为一个请求IO会阻塞进程，所以，得为每请求分配一个处理进程（线程）以及时响应，系统开销大。</p>\n<h3><strong>2. 非阻塞IO模型</strong></h3>\n<p><img src=\"@Img_IO/2024-07-08-17-29-47-image.png\" alt=\"\"></p>\n<p>进程发起IO系统调用后，如果内核缓冲区没有数据，需要到IO设备中读取，进程返回一个错误而不会被阻塞；进程发起IO系统调用后，如果内核缓冲区有数据，内核就会把数据返回进程。</p>\n<p>对于上面的阻塞IO模型来说，内核数据没准备好需要进程阻塞的时候，就返回一个错误，以使得进程不被阻塞。</p>\n<p>1、典型应用：socket是非阻塞的方式（设置为NONBLOCK）</p>\n<p>2、特点：</p>\n<ul>\n<li>进程轮询（重复）调用，消耗CPU的资源；</li>\n<li>实现难度低、开发应用相对阻塞IO模式较难；</li>\n<li>适用并发量较小、且不需要及时响应的网络应用开发；</li>\n</ul>\n<h3>3. <strong>IO复用模型</strong></h3>\n<p><img src=\"@Img_IO/2024-07-08-17-29-56-image.png\" alt=\"\"></p>\n<p>多个的进程的IO可以注册到一个复用器（select）上，然后用一个进程调用该select， select会监听所有注册进来的IO；</p>\n<p>如果select没有监听的IO在内核缓冲区都没有可读数据，select调用进程会被阻塞；而当任一IO在内核缓冲区中有可数据时，select调用就会返回；</p>\n<p>而后select调用进程可以自己或通知另外的进程（注册进程）来再次发起读取IO，读取内核中准备好的数据。</p>\n<p>可以看到，多个进程注册IO后，只有另一个select调用进程被阻塞。</p>\n<p>1、典型应用：select、poll、epoll三种方案，nginx都可以选择使用这三个方案;Java NIO;</p>\n<p>2、特点：</p>\n<ul>\n<li>专一进程解决多个进程IO的阻塞问题，性能好；Reactor模式;</li>\n<li>实现、开发应用难度较大；</li>\n<li>适用高并发服务应用开发：一个进程（线程）响应多个请求；</li>\n</ul>\n<p>3、select、poll、epoll</p>\n<ul>\n<li>Linux中IO复用的实现方式主要有select、poll和epoll：</li>\n<li>Select：注册IO、阻塞扫描，监听的IO最大连接数不能多于FD_SIZE；</li>\n<li>Poll：原理和Select相似，没有数量限制，但IO数量大扫描线性性能下降；</li>\n<li>Epoll ：事件驱动不阻塞，mmap实现内核与用户空间的消息传递，数量很大，Linux2.6后内核支持；</li>\n</ul>\n<h3>4. <strong>信号驱动IO模型</strong></h3>\n<p><img src=\"@Img_IO/2024-07-08-17-53-52-image.png\" alt=\"\"></p>\n<p>当进程发起一个IO操作，会向内核注册一个信号处理函数，然后进程返回不阻塞；当内核数据就绪时会发送一个信号给进程，进程便在信号处理函数中调用IO读取数据。</p>\n<p>特点：回调机制，实现、开发应用难度大；</p>\n<h3>5. <strong>异步IO模型</strong></h3>\n<p><img src=\"@Img_IO/2024-07-08-17-30-06-image.png\" alt=\"\"></p>\n<p>当进程发起一个IO操作，进程返回（不阻塞），但也不能返回果结；内核把整个IO处理完后，会通知进程结果。如果IO操作成功则进程直接获取到数据。</p>\n<p>1、典型应用：JAVA7 AIO、高性能<a href=\"https://cloud.tencent.com/act/pro/promotion-cvm?from_column=20065&amp;from=20065\">服务器</a>应用</p>\n<p>2、特点：</p>\n<ul>\n<li>不阻塞，数据一步到位；Proactor模式；</li>\n<li>需要操作系统的底层支持，LINUX 2.5 版本内核首现，2.6 版本产品的内核标准特性；</li>\n<li>实现、开发应用难度大；</li>\n<li>非常适合高性能高并发应用；</li>\n</ul>\n<p><img src=\"@Img_IO/2024-07-08-17-56-27-image.png\" alt=\"\"></p>\n<p><img src=\"@Img_IO/2024-07-08-17-31-21-image.png\" alt=\"\"></p>\n<p><img src=\"@Img_IO/2024-07-08-18-09-13-image.png\" alt=\"\"></p>\n<p><img src=\"@Img_IO/2024-07-09-09-23-09-image.png\" alt=\"\"></p>\n",
    "path": "/pages/IO模型.html",
    "name": "IO模型"
  },
  {
    "profile": {
      "date": "2024-10-06",
      "category": ["学习拓展"],
      "tag": ["分布式一致性算法", "raft"]
    },
    "htmlContent": "<h1><strong>一、Raft 概述</strong></h1>\n<p>Raft 算法是分布式系统开发首选的共识算法。比如现在流行 Etcd、Consul。</p>\n<p>如果掌握了这个算法，就可以较容易地处理绝大部分场景的容错和一致性需求。比如分布式配置系统、分布式 NoSQL 存储等等，轻松突破系统的单机限制。</p>\n<p><strong>Raft 算法是通过一切以领导者为准的方式，实现一系列值的共识和各节点日志的一致。</strong></p>\n<h1><strong>二、Raft 角色</strong></h1>\n<p><strong>2.1 角色</strong></p>\n<p><strong>跟随者（Follower）</strong>：普通群众，默默接收和来自领导者的消息，当领导者心跳信息超时的时候，就主动站出来，推荐自己当候选人。</p>\n<p><strong>候选人（Candidate）</strong>：候选人将向其他节点请求投票 RPC 消息，通知其他节点来投票，如果赢得了大多数投票选票，就晋升当领导者。</p>\n<p><strong>领导者（Leader）</strong>：霸道总裁，一切以我为准。处理写请求、管理日志复制和不断地发送心跳信息，通知其他节点“我是领导者，我还活着，你们不要”发起新的选举，不用找新领导来替代我。</p>\n<p>如下图所示，分别用三种图代表跟随者、候选人和领导者。</p>\n<p>角色</p>\n<h1><strong>三、单节点系统</strong></h1>\n<p><strong>3.1 数据库服务器</strong></p>\n<p>现在我们想象一下，有一个单节点系统，这个节点作为数据库服务器，且存储了一个值为 X。</p>\n<p>数据库服务器</p>\n<p><strong>3.2 客户端</strong></p>\n<p>左边绿色的实心圈就是客户端，右边的蓝色实心圈就是节点 a（Node a）。Term 代表任期，后面会讲到。</p>\n<p>客户端</p>\n<p><strong>3.3 客户端向服务器发送数据</strong></p>\n<p>客户端向单节点服务器发送了一条更新操作，设置数据库中存的值为 8。单机环境下（单个服务器节点），客户端从服务器拿到的值也是 8。一致性非常容易保证。</p>\n<p>客户端向服务器发送数据</p>\n<p><strong>3.4 多节点如何保证一致性？</strong></p>\n<p>但如果有多个服务器节点，怎么保证一致性呢？比如有三个节点：a，b，c。如下图所示。这三个节点组成一个数据库集群。客户端对这三个节点进行更新操作，如何保证三个节点中存的值一致？这个就是分布式一致性问题。Raft 算法就是来解决这个问题的。当然还有其他协议也可以保证，本篇只针对 Raft 算法。</p>\n<p>在多节点集群中，在节点故障、分区错误等异常情况下，Raft 算法如何保证在同一个时间，集群中只有一个领导者呢？下面就开始讲解 Raft 算法选举领导者的过程。</p>\n<h1><strong>四、选举领导过程</strong></h1>\n<p><strong>4.1 初始状态</strong></p>\n<p>初始状态下，集群中所有节点都是跟随者的状态。</p>\n<p>如下图所示，有三个节点(Node) a、b、c，任期（Term）都为 0。</p>\n<p>初始状态</p>\n<p><strong>4.2 成为候选者</strong></p>\n<p>Raft 算法实现了随机超时时间的特性，每个节点等待领导者节点心跳信息的超时时间间隔是随机的。比如 A 节点等待超时的时间间隔 150 ms，B 节点 200 ms，C 节点 300 ms。那么 a 先超时，最先因为没有等到领导者的心跳信息，发生超时。如下图所示，三个节点的超时计时器开始运行。</p>\n<p>超时时间</p>\n<p>当 A 节点的超时时间到了后，A 节点成为候选者，并增加自己的任期编号，Term 值从 0 更新为 1，并给自己投了一票。</p>\n<ul>\n<li>\n<p>Node A：Term = 1, Vote Count = 1。</p>\n</li>\n<li>\n<p>Node B：Term = 0。</p>\n</li>\n<li>\n<p>Node C：Term = 0。</p>\n</li>\n</ul>\n<p>成为候选者</p>\n<p><strong>4.3 投票</strong></p>\n<p>我们来看下候选者如何成为领导者的。</p>\n<p>Leader 选举</p>\n<ul>\n<li>第一步</li>\n</ul>\n<p>：节点 A 成为候选者后，向其他节点发送请求投票 RPC 信息，请它们选举自己为领导者。</p>\n<ul>\n<li>第二步</li>\n</ul>\n<p>：节点 B 和 节点 C 接收到节点 A 发送的请求投票信息后，在编号为 1 的这届任期内，还没有进行过投票，就把选票投给节点 A，并增加自己的任期编号。</p>\n<ul>\n<li>第三步</li>\n</ul>\n<p>：节点 A 收到 3 次投票，得到了大多数节点的投票，从候选者成为本届任期内的新的领导者。</p>\n<ul>\n<li>第四步</li>\n</ul>\n<p>：节点 A 作为领导者，固定的时间间隔给 节点 B 和节点 C 发送心跳信息，告诉节点 B 和 C，我是领导者，组织其他跟随者发起新的选举。</p>\n<ul>\n<li>第五步</li>\n</ul>\n<p>：节点 B 和节点 C 发送响应信息给节点 A，告诉节点 A 我是正常的。</p>\n<p><strong>4.4 任期</strong></p>\n<p>英文单词是 term，领导者是有任期的。</p>\n<ul>\n<li>自动增加</li>\n</ul>\n<p>：跟随者在等待领导者心跳信息超时后，推荐自己为候选人，会增加自己的任期号，如上图所示，节点 A 任期为 0，推举自己为候选人时，任期编号增加为 1。</p>\n<ul>\n<li>更新为较大值</li>\n</ul>\n<p>：当节点发现自己的任期编号比其他节点小时，会更新到较大的编号值。比如节点 A 的任期为 1，请求投票，投票消息中包含了节点 A 的任期编号，且编号为 1，节点 B 收到消息后，会将自己的任期编号更新为 1。</p>\n<ul>\n<li>恢复为跟随者</li>\n</ul>\n<p>：如果一个候选人或者领导者，发现自己的任期编号比其他节点小，那么它会立即恢复成跟随者状态。这种场景出现在分区错误恢复后，任期为 3 的领导者受到任期编号为 4 的心跳消息，那么前者将立即恢复成跟随者状态。</p>\n<ul>\n<li>拒绝消息</li>\n</ul>\n<p>：如果一个节点接收到较小的任期编号值的请求，那么它会直接拒绝这个请求，比如任期编号为 6 的节点 A，收到任期编号为 5 的节点 B 的请求投票 RPC 消息，那么节点 A 会拒绝这个消息。</p>\n<p><strong>4.5 选举规则</strong></p>\n<ul>\n<li>\n<p>一个任期内，领导者一直都会领导者，直到自身出现问题（如宕机），或者网络问题（延迟），其他节点发起一轮新的选举。</p>\n</li>\n<li>\n<p>在一次选举中，每一个服务器节点最多会对一个任期编号投出一张选票，投完了就没了。</p>\n</li>\n</ul>\n<p><strong>4.6 大多数</strong></p>\n<p>假设一个集群由 N 个节点组成，那么大多数就是至少 N/2+1。例如：3 个节点的集群，大多数就是 2。</p>\n<p><strong>4.7 心跳超时</strong></p>\n<p>为了防止多个节点同时发起投票，会给每个节点分配一个随机的选举超时时间。这个时间内，节点不能成为候选者，只能等到超时。比如上述例子，节点 A 先超时，先成为了候选者。这种巧妙的设计，在大多数情况下只有一个服务器节点先发起选举，而不是同时发起选举，减少了因选票瓜分导致选举失败的情况。</p>\n<p>成为候选者</p>\n<h1><strong>五、领导者故障</strong></h1>\n<p>如果领导者节点出现故障，则会触发新的一轮选举。如下图所示，领导者节点 A 发生故障，节点 B 和 节点 C 就会重新选举 Leader。</p>\n<p>领导者故障</p>\n<ul>\n<li>第一步</li>\n</ul>\n<p>：节点 A 发生故障，节点 B 和节点 C 没有收到领导者节点 A 的心跳信息，等待超时。</p>\n<ul>\n<li>第二步</li>\n</ul>\n<p>：节点 C 先发生超时，节点 C 成为候选人。</p>\n<ul>\n<li>第三步</li>\n</ul>\n<p>：节点 C 向节点 A 和节点 B 发起请求投票信息。</p>\n<ul>\n<li>第四步</li>\n</ul>\n<p>：节点 C 响应投票，将票投给了 C，而节点 A 因为发生故障了，无法响应 C 的投票请求。</p>\n<ul>\n<li>第五步</li>\n</ul>\n<p>：节点 C 收到两票（大多数票数），成为领导者。</p>\n<ul>\n<li>第六步</li>\n</ul>\n<p>：节点 C 向节点 A 和 B 发送心跳信息，节点 B 响应心跳信息，节点 A 不响应心跳信息，因为 A 故障了。</p>\n<h1><strong>总结</strong></h1>\n<p>Raft 算法通过以下几种方式来进行领导选举，保证了一个任期只有一位领导，极大减少了选举失败的情况。</p>\n<ul>\n<li>\n<p>任期</p>\n</li>\n<li>\n<p>领导者心跳信息</p>\n</li>\n<li>\n<p>随机选举超时时间</p>\n</li>\n<li>\n<p>先来先服务的投票原则</p>\n</li>\n<li>\n<p>大多数选票原则</p>\n</li>\n</ul>\n",
    "path": "/pages/Raft.html",
    "name": "Raft"
  },
  {
    "profile": { "date": "2024-10-06", "category": ["学习拓展"], "tag": ["进程", "线程", "协程"] },
    "htmlContent": "<h3>进程切换开销</h3>\n<ol>\n<li>直接开销•\n<ul>\n<li>切换页表全局目录（PGD）</li>\n<li>切换内核态堆栈</li>\n<li>切换硬件上下文（进程恢复前，必须装入寄存器的数据统称为硬件上下文）</li>\n<li>刷新TLB</li>\n<li>系统调度器的代码执行</li>\n</ul>\n</li>\n<li>间接开销\n<ul>\n<li>CPU 缓存失效导致的进程需要到内存直接访问的IO 操作变多</li>\n</ul>\n</li>\n</ol>\n<h3>线程切换开销</h3>\n<ul>\n<li>线程本质上只是一批共享资源的进程，线程切换本质上依然需要内核进行进程切换</li>\n<li>一组线程因为共享内存资源，因此一个进程的所有线程共享虚拟地址空间</li>\n<li>线程切换相比进程切换，主要节省了虚拟地址空间的切换</li>\n</ul>\n<h3>协程切换开销</h3>\n<p>用户线程无需内核帮助，应用程序在用户空间创建的可执行单元，创建销毁完全在用户态完成</p>\n",
    "path": "/pages/进程_线程_协程.html",
    "name": "进程_线程_协程"
  }
]
