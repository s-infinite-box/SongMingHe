[{"profile":{"date":"2024-10-09","category":"学习拓展","tag":["进程","线程","协程"]},"htmlContent":"<h2>如今，软件通常会作为一种服务来交付，它们被称为网络应用程序，或软件即服务（SaaS）。12-Factor 为构建如下的 SaaS 应用提供了方法论：</h2>\n<ul>\n<li>\n<p>使用标准化流程自动配置，从而使新的开发者花费最少的学习成本加入这个项目。</p>\n</li>\n<li>\n<p>和操作系统之间尽可能的划清界限，在各个系统中提供最大的可移植性。</p>\n</li>\n<li>\n<p>适合部署在现代的云计算平台，从而在服务器和系统管理方面节省资源。</p>\n</li>\n<li>\n<p>将开发环境和生产环境的差异降至最低，并使用持续交付实施敏捷开发。</p>\n</li>\n<li>\n<p>可以在工具、架构和开发流程不发生明显变化的前提下实现扩展。</p>\n</li>\n<li>\n<p>这套理论适用于任意语言和后端服务（数据库、消息队列、缓存等）开发的应用程序。</p>\n</li>\n</ul>\n<h2>背景</h2>\n<p>本文的贡献者者参与过数以百计的应用程序的开发和部署，并通过 Heroku 平台间接见证了数十万应用程序的开发，运作以及扩展的过程。 本文综合了我们关于 SaaS 应用几乎所有的经验和智慧，是开发此类应用的理想实践标准，并特别关注于应用程序如何保持良性成长，开发者之间如何进行有效的代码协作，以及如何 避免软件污染 。 我们的初衷是分享在现代软件开发过程中发现的一些系统性问题，并加深对这些问题的认识。我们提供了讨论这些问题时所需的共享词汇，同时使用相关术语给出一套针对这些问题的广义解决方案。 本文格式的灵感来自于 Martin Fowler 的书籍： Patterns of Enterprise Application Architecture ， Refactoring 。</p>\n<h1>云原生应用的12要素</h1>\n<p>I. 基准代码</p>\n<p>一份基准代码（Codebase），多份部署（deploy） 12-Factor应用(译者注：应该是说一个使用本文概念来设计的应用，下同)通常会使用版本控制系统加以管理，如Git, Mercurial, Subversion。一份用来跟踪代码所有修订版本的数据库被称作 代码库（code repository, code repo, repo）。 在类似 SVN 这样的集中式版本控制系统中，基准代码 就是指控制系统中的这一份代码库；而在 Git 那样的分布式版本控制系统中，基准代码 则是指最上游的那份代码库。</p>\n<p>一份代码库对应多份部署</p>\n<p>基准代码和应用之间总是保持一一对应的关系：</p>\n<ul>\n<li>\n<p>一旦有多个基准代码，就不能称为一个应用，而是一个分布式系统。分布式系统中的每一个组件都是一个应用，每一个应用可以分别使用 12-Factor 进行开发。</p>\n</li>\n<li>\n<p>多个应用共享一份基准代码是有悖于 12-Factor 原则的。解决方案是将共享的代码拆分为独立的类库，然后使用 依赖管理 策略去加载它们。</p>\n</li>\n</ul>\n<p>尽管每个应用只对应一份基准代码，但可以同时存在多份部署。每份 部署 相当于运行了一个应用的实例。通常会有一个生产环境，一个或多个预发布环境。此外，每个开发人员都会在自己本地环境运行一个应用实例，这些都相当于一份部署。 所有部署的基准代码相同，但每份部署可以使用其不同的版本。比如，开发人员可能有一些提交还没有同步至预发布环境；预发布环境也有一些提交没有同步至生产环境。但它们都共享一份基准代码，我们就认为它们只是相同应用的不同部署而已。</p>\n<p>II. 依赖</p>\n<p>显式声明依赖关系（ dependency ） 大多数编程语言都会提供一个打包系统，用来为各个类库提供打包服务，就像 Perl 的 CPAN 或是 Ruby 的 Rubygems 。通过打包系统安装的类库可以是系统级的（称之为 “site packages”），或仅供某个应用程序使用，部署在相应的目录中（称之为 “vendoring” 或 “bunding”）。 12-Factor规则下的应用程序不会隐式依赖系统级的类库。 它一定通过 依赖清单 ，确切地声明所有依赖项。此外，在运行过程中通过 依赖隔离 工具来确保程序不会调用系统中存在但清单中未声明的依赖项。这一做法会统一应用到生产和开发环境。例如， Ruby 的 Bundler 使用 Gemfile 作为依赖项声明清单，使用 bundle exec 来进行依赖隔离。Python 中则可分别使用两种工具 – Pip 用作依赖声明， Virtualenv 用作依赖隔离。甚至 C 语言也有类似工具， Autoconf 用作依赖声明，静态链接库用作依赖隔离。无论用什么工具，依赖声明和依赖隔离必须一起使用，否则无法满足 12-Factor 规范。显式声明依赖的优点之一是为新进开发者简化了环境配置流程。新进开发者可以检出应用程序的基准代码，安装编程语言环境和它对应的依赖管理工具，只需通过一个 构建命令 来安装所有的依赖项，即可开始工作。例如，Ruby/Bundler 下使用 bundle install，而 Clojure/Leiningen 则是 lein deps。12-Factor 应用同样不会隐式依赖某些系统工具，如 ImageMagick 或是 curl。即使这些工具存在于几乎所有系统，但终究无法保证所有未来的系统都能支持应用顺利运行，或是能够和应用兼容。如果应用必须使用到某些系统工具，那么这些工具应该被包含在应用之中。</p>\n<p>III. 配置</p>\n<p>在环境中存储配置 通常，应用的 配置 在不同 部署 (预发布、生产环境、开发环境等等)间会有很大差异。这其中包括：</p>\n<ul>\n<li>\n<p>数据库，Memcached，以及其他 后端服务 的配置</p>\n</li>\n<li>\n<p>第三方服务的证书，如 Amazon S3、Twitter 等</p>\n</li>\n<li>\n<p>每份部署特有的配置，如域名等</p>\n</li>\n</ul>\n<p>有些应用在代码中使用常量保存配置，这与 12-Factor 所要求的代码和配置严格分离显然大相径庭。配置文件在各部署间存在大幅差异，代码却完全一致。 判断一个应用是否正确地将配置排除在代码之外，一个简单的方法是看该应用的基准代码是否可以立刻开源，而不用担心会暴露任何敏感的信息。需要指出的是，这里定义的“配置”并不包括应用的内部配置，比如 Rails 的 config/routes.rb，或是使用 Spring 时 代码模块间的依赖注入关系 。这类配置在不同部署间不存在差异，所以应该写入代码。另外一个解决方法是使用配置文件，但不把它们纳入版本控制系统，就像 Rails 的 config/database.yml 。这相对于在代码中使用常量已经是长足进步，但仍然有缺点：总是会不小心将配置文件签入了代码库；配置文件的可能会分散在不同的目录，并有着不同的格式，这让找出一个地方来统一管理所有配置变的不太现实。更糟的是，这些格式通常是语言或框架特定的。 12-Factor推荐将应用的配置存储于 环境变量 中（ env vars, env ）。环境变量可以非常方便地在不同的部署间做修改，却不动一行代码；与配置文件不同，不小心把它们签入代码库的概率微乎其微；与一些传统的解决配置问题的机制（比如 Java 的属性配置文件）相比，环境变量与语言和系统无关。配置管理的另一个方面是分组。有时应用会将配置按照特定部署进行分组（或叫做“环境”），例如Rails中的 development, test, 和 production 环境。这种方法无法轻易扩展：更多部署意味着更多新的环境，例如 staging 或 qa。随着项目的不断深入，开发人员可能还会添加他们自己的环境，比如 joes-staging，这将导致各种配置组合的激增，从而给管理部署增加了很多不确定因素。 12-Factor 应用中，环境变量的粒度要足够小，且相对独立。它们永远也不会组合成一个所谓的“环境”，而是独立存在于每个部署之中。当应用程序不断扩展，需要更多种类的部署时，这种配置管理方式能够做到平滑过渡。</p>\n<p>IV. 后端服务</p>\n<p>把后端服务(backing services)当作附加资源 后端服务是指程序运行所需要的通过网络调用的各种服务，如数据库（MySQL，CouchDB），消息/队列系统（RabbitMQ，Beanstalkd），SMTP 邮件发送服务（Postfix），以及缓存系统（Memcached）。 类似数据库的后端服务，通常由部署应用程序的系统管理员一起管理。除了本地服务之外，应用程序有可能使用了第三方发布和管理的服务。示例包括 SMTP（例如 Postmark），数据收集服务（例如 New Relic 或 Loggly），数据存储服务（如 Amazon S3），以及使用 API 访问的服务（例如 Twitter, Google Maps, Last.fm）。 12-Factor 应用不会区别对待本地或第三方服务。 对应用程序而言，两种都是附加资源，通过一个 url 或是其他存储在 配置中的服务定位/服务证书来获取数据。12-Factor 应用的任意 部署 ，都应该可以在不进行任何代码改动的情况下，将本地 MySQL 数据库换成第三方服务（例如 Amazon RDS）。类似的，本地 SMTP 服务应该也可以和第三方 SMTP 服务（例如 Postmark ）互换。上述 2 个例子中，仅需修改配置中的资源地址。 每个不同的后端服务是一份 资源 。例如，一个 MySQL 数据库是一个资源，两个 MySQL 数据库（用来数据分区）就被当作是 2 个不同的资源。12-Factor 应用将这些数据库都视作 附加资源 ，这些资源和它们附属的部署保持松耦合。</p>\n<p>一种部署附加4个后端服务 部署可以按需加载或卸载资源。例如，如果应用的数据库服务由于硬件问题出现异常，管理员可以从最近的备份中恢复一个数据库，卸载当前的数据库，然后加载新的数据库 – 整个过程都不需要修改代码。</p>\n<p>V. 构建，发布，运行</p>\n<p>严格分离构建和运行 基准代码 转化为一份部署(非开发环境)需要以下三个阶段：</p>\n<ul>\n<li>\n<p>构建阶段 是指将代码仓库转化为可执行包的过程。构建时会使用指定版本的代码，获取和打包 依赖项，编译成二进制文件和资源文件。</p>\n</li>\n<li>\n<p>发布阶段 会将构建的结果和当前部署所需 配置 相结合，并能够立刻在运行环境中投入使用。</p>\n</li>\n<li>\n<p>运行阶段 （或者说“运行时”）是指针对选定的发布版本，在执行环境中启动一系列应用程序 进程。</p>\n</li>\n</ul>\n<p>代码被构建，然后和配置结合成为发布版本</p>\n<p>12-facfor 应用严格区分构建，发布，运行这三个步骤。 举例来说，直接修改处于运行状态的代码是非常不可取的做法，因为这些修改很难再同步回构建步骤。部署工具通常都提供了发布管理工具，最引人注目的功能是退回至较旧的发布版本。比如， Capistrano 将所有发布版本都存储在一个叫 releases 的子目录中，当前的在线版本只需映射至对应的目录即可。该工具的 rollback 命令可以很容易地实现回退版本的功能。每一个发布版本必须对应一个唯一的发布 ID，例如可以使用发布时的时间戳（ 2011-04-06-20:32:17），亦或是一个增长的数字（ v100）。发布的版本就像一本只能追加的账本，一旦发布就不可修改，任何的变动都应该产生一个新的发布版本。 新的代码在部署之前，需要开发人员触发构建操作。但是，运行阶段不一定需要人为触发，而是可以自动进行。如服务器重启，或是进程管理器重启了一个崩溃的进程。因此，运行阶段应该保持尽可能少的模块，这样假设半夜发生系统故障而开发人员又捉襟见肘也不会引起太大问题。构建阶段是可以相对复杂一些的，因为错误信息能够立刻展示在开发人员面前，从而得到妥善处理。</p>\n<p>VI. 进程</p>\n<p>以一个或多个无状态进程运行应用 运行环境中，应用程序通常是以一个和多个 进程 运行的。 最简单的场景中，代码是一个独立的脚本，运行环境是开发人员自己的笔记本电脑，进程由一条命令行（例如python my_script.py）。另外一个极端情况是，复杂的应用可能会使用很多 进程类型 ，也就是零个或多个进程实例。 12-Factor 应用的进程必须无状态且 无共享 。 任何需要持久化的数据都要存储在 后端服务 内，比如数据库。 内存区域或磁盘空间可以作为进程在做某种事务型操作时的缓存，例如下载一个很大的文件，对其操作并将结果写入数据库的过程。12-Factor应用根本不用考虑这些缓存的内容是不是可以保留给之后的请求来使用，这是因为应用启动了多种类型的进程，将来的请求多半会由其他进程来服务。即使在只有一个进程的情形下，先前保存的数据（内存或文件系统中）也会因为重启（如代码部署、配置更改、或运行环境将进程调度至另一个物理区域执行）而丢失。 源文件打包工具（Jammit, django-compressor） 使用文件系统来缓存编译过的源文件。12-Factor 应用更倾向于在 构建步骤做此动作——正如 Rails资源管道 ，而不是在运行阶段。 一些互联网系统依赖于 “粘性 session”， 这是指将用户 session 中的数据缓存至某进程的内存中，并将同一用户的后续请求路由到同一个进程。粘性 session 是 12-Factor 极力反对的。Session 中的数据应该保存在诸如 Memcached 或 Redis 这样的带有过期时间的缓存中。</p>\n<p>VII. 端口绑定</p>\n<p>通过端口绑定(Port binding)来提供服务 互联网应用有时会运行于服务器的容器之中。例如 PHP 经常作为 Apache HTTPD 的一个模块来运行，正如 Java 运行于 Tomcat 。 12-Factor 应用完全自我加载 而不依赖于任何网络服务器就可以创建一个面向网络的服务。互联网应用 通过端口绑定来提供服务 ，并监听发送至该端口的请求。本地环境中，开发人员通过类似 <a href=\"http://localhost:5000/%E7%9A%84%E5%9C%B0%E5%9D%80%E6%9D%A5%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E3%80%82%E5%9C%A8%E7%BA%BF%E4%B8%8A%E7%8E%AF%E5%A2%83%E4%B8%AD%EF%BC%8C%E8%AF%B7%E6%B1%82%E7%BB%9F%E4%B8%80%E5%8F%91%E9%80%81%E8%87%B3%E5%85%AC%E5%85%B1%E5%9F%9F%E5%90%8D%E8%80%8C%E5%90%8E%E8%B7%AF%E7%94%B1%E8%87%B3%E7%BB%91%E5%AE%9A%E4%BA%86%E7%AB%AF%E5%8F%A3%E7%9A%84%E7%BD%91%E7%BB%9C%E8%BF%9B%E7%A8%8B%E3%80%82\">http://localhost:5000/的地址来访问服务。在线上环境中，请求统一发送至公共域名而后路由至绑定了端口的网络进程。</a> 通常的实现思路是，将网络服务器类库通过 依赖声明 载入应用。例如，Python 的 Tornado, Ruby 的Thin , Java 以及其他基于 JVM 语言的 Jetty。完全由 用户端 ，确切的说应该是应用的代码，发起请求。和运行环境约定好绑定的端口即可处理这些请求。 HTTP 并不是唯一一个可以由端口绑定提供的服务。其实几乎所有服务器软件都可以通过进程绑定端口来等待请求。例如，使用 XMPP 的 ejabberd ， 以及使用 Redis 协议 的 Redis 。 还要指出的是，端口绑定这种方式也意味着一个应用可以成为另外一个应用的 后端服务 ，调用方将服务方提供的相应 URL 当作资源存入 配置 以备将来调用。</p>\n<p>VIII. 并发</p>\n<p>通过进程模型进行扩展 任何计算机程序，一旦启动，就会生成一个或多个进程。互联网应用采用多种进程运行方式。例如，PHP 进程作为 Apache 的子进程存在，随请求按需启动。Java 进程则采取了相反的方式，在程序启动之初 JVM 就提供了一个超级进程储备了大量的系统资源(CPU 和内存)，并通过多线程实现内部的并发管理。上述 2 个例子中，进程是开发人员可以操作的最小单位。</p>\n<p>扩展表现为运行中的进程，工作多样性表现为进程类型。</p>\n<p>在 12-factor 应用中，进程是一等公民。12-Factor 应用的进程主要借鉴于 unix 守护进程模型 。开发人员可以运用这个模型去设计应用架构，将不同的工作分配给不同的 进程类型 。例如，HTTP 请求可以交给 web 进程来处理，而常驻的后台工作则交由 worker 进程负责。 这并不包括个别较为特殊的进程，例如通过虚拟机的线程处理并发的内部运算，或是使用诸如 EventMachine, Twisted, Node.js 的异步/事件触发模型。但一台独立的虚拟机的扩展有瓶颈（垂直扩展），所以应用程序必须可以在多台物理机器间跨进程工作。 上述进程模型会在系统急需扩展时大放异彩。12-Factor 应用的进程所具备的无共享，水平分区的特性 意味着添加并发会变得简单而稳妥。这些进程的类型以及每个类型中进程的数量就被称作 进程构成 。 12-Factor 应用的进程 不需要守护进程 或是写入 PID 文件。相反的，应该借助操作系统的进程管理器(例如 Upstart ，分布式的进程管理云平台，或是类似 Foreman 的工具)，来管理 输出流 ，响应崩溃的进程，以及处理用户触发的重启和关闭超级进程的请求。</p>\n<p>IX. 易处理</p>\n<p>快速启动和优雅终止可最大化健壮性 12-Factor 应用的 进程 是 易处理（disposable）的，意思是说它们可以瞬间开启或停止。 这有利于快速、弹性的伸缩应用，迅速部署变化的 代码 或 配置 ，稳健的部署应用。 进程应当追求 最小启动时间 。理想状态下，进程从敲下命令到真正启动并等待请求的时间应该只需很短的时间。更少的启动时间提供了更敏捷的 发布 以及扩展过程，此外还增加了健壮性，因为进程管理器可以在授权情形下容易的将进程搬到新的物理机器上。 进程 一旦接收 终止信号（SIGTERM） 就会优雅的终止 。就网络进程而言，优雅终止是指停止监听服务的端口，即拒绝所有新的请求，并继续执行当前已接收的请求，然后退出。此类型的进程所隐含的要求是HTTP请求大多都很短(不会超过几秒钟)，而在长时间轮询中，客户端在丢失连接后应该马上尝试重连。对于 worker 进程来说，优雅终止是指将当前任务退回队列。例如，RabbitMQ 中，worker 可以发送一个 NACK信号。Beanstalkd 中，任务终止并退回队列会在worker断开时自动触发。有锁机制的系统诸如 Delayed Job 则需要确定释放了系统资源。此类型的进程所隐含的要求是，任务都应该 可重复执行 ， 这主要由将结果包装进事务或是使重复操作 幂等 来实现。 进程还应当在面对突然死亡时保持健壮，例如底层硬件故障。虽然这种情况比起优雅终止来说少之又少，但终究有可能发生。一种推荐的方式是使用一个健壮的后端队列，例如 Beanstalkd ，它可以在客户端断开或超时后自动退回任务。无论如何，12-Factor 应用都应该可以设计能够应对意外的、不优雅的终结。Crash-only design 将这种概念转化为 合乎逻辑的理论。</p>\n<p>X. 开发环境与线上环境等价</p>\n<p>尽可能的保持开发，预发布，线上环境相同 从以往经验来看，开发环境（即开发人员的本地 部署）和线上环境（外部用户访问的真实部署）之间存在着很多差异。这些差异表现在以下三个方面：</p>\n<ul>\n<li>\n<p>时间差异： 开发人员正在编写的代码可能需要几天，几周，甚至几个月才会上线。</p>\n</li>\n<li>\n<p>人员差异： 开发人员编写代码，运维人员部署代码。</p>\n</li>\n<li>\n<p>工具差异： 开发人员或许使用 Nginx，SQLite，OS X，而线上环境使用 Apache，MySQL 以及 Linux。 12-Factor 应用想要做到 持续部署 就必须缩小本地与线上差异。 再回头看上面所描述的三个差异:</p>\n</li>\n<li>\n<p>缩小时间差异：开发人员可以几小时，甚至几分钟就部署代码。</p>\n</li>\n<li>\n<p>缩小人员差异：开发人员不只要编写代码，更应该密切参与部署过程以及代码在线上的表现。</p>\n</li>\n<li>\n<p>缩小工具差异：尽量保证开发环境以及线上环境的一致性。</p>\n</li>\n</ul>\n<p>将上述总结变为一个表格如下： 传统应用12-Factor 应用每次部署间隔数周几小时开发人员 vs 运维人员不同的人相同的人开发环境 vs 线上环境不同尽量接近 后端服务 是保持开发与线上等价的重要部分，例如数据库，队列系统，以及缓存。许多语言都提供了简化获取后端服务的类库，例如不同类型服务的 适配器 。下列表格提供了一些例子。 类型语言类库适配器数据库Ruby/RailsActiveRecordMySQL, PostgreSQL, SQLite队列Python/DjangoCeleryRabbitMQ, Beanstalkd, Redis缓存Ruby/RailsActiveSupport::CacheMemory, filesystem, Memcached 开发人员有时会觉得在本地环境中使用轻量的后端服务具有很强的吸引力，而那些更重量级的健壮的后端服务应该使用在生产环境。例如，本地使用 SQLite 线上使用 PostgreSQL；又如本地缓存在进程内存中而线上存入 Memcached。 12-Factor 应用的开发人员应该反对在不同环境间使用不同的后端服务 ，即使适配器已经可以几乎消除使用上的差异。这是因为，不同的后端服务意味着会突然出现的不兼容，从而导致测试、预发布都正常的代码在线上出现问题。这些错误会给持续部署带来阻力。从应用程序的生命周期来看，消除这种阻力需要花费很大的代价。 与此同时，轻量的本地服务也不像以前那样引人注目。借助于Homebrew，apt-get等现代的打包系统，诸如Memcached、PostgreSQL、RabbitMQ 等后端服务的安装与运行也并不复杂。此外，使用类似 Chef 和 Puppet 的声明式配置工具，结合像 Vagrant 这样轻量的虚拟环境就可以使得开发人员的本地环境与线上环境无限接近。与同步环境和持续部署所带来的益处相比，安装这些系统显然是值得的。 不同后端服务的适配器仍然是有用的，因为它们可以使移植后端服务变得简单。但应用的所有部署，这其中包括开发、预发布以及线上环境，都应该使用同一个后端服务的相同版本。</p>\n<p>XI. 日志</p>\n<p>把日志当作事件流 日志 使得应用程序运行的动作变得透明。在基于服务器的环境中，日志通常被写在硬盘的一个文件里，但这只是一种输出格式。 日志应该是 事件流 的汇总，将所有运行中进程和后端服务的输出流按照时间顺序收集起来。尽管在回溯问题时可能需要看很多行，日志最原始的格式确实是一个事件一行。日志没有确定开始和结束，但随着应用在运行会持续的增加。12-factor应用本身从不考虑存储自己的输出流。 不应该试图去写或者管理日志文件。相反，每一个运行的进程都会直接的标准输出（ stdout）事件流。开发环境中，开发人员可以通过这些数据流，实时在终端看到应用的活动。 在预发布或线上部署中，每个进程的输出流由运行环境截获，并将其他输出流整理在一起，然后一并发送给一个或多个最终的处理程序，用于查看或是长期存档。这些存档路径对于应用来说不可见也不可配置，而是完全交给程序的运行环境管理。类似 Logplex 和 Fluent 的开源工具可以达到这个目的。 这些事件流可以输出至文件，或者在终端实时观察。最重要的，输出流可以发送到 Splunk 这样的日志索引及分析系统，或 Hadoop/Hive 这样的通用数据存储系统。这些系统为查看应用的历史活动提供了强大而灵活的功能，包括：</p>\n<ul>\n<li>\n<p>找出过去一段时间特殊的事件。</p>\n</li>\n<li>\n<p>图形化一个大规模的趋势，比如每分钟的请求量。</p>\n</li>\n<li>\n<p>根据用户定义的条件实时触发警报，比如每分钟的报错超过某个警戒线。</p>\n</li>\n</ul>\n<p>XII. 管理进程</p>\n<p>后台管理任务当作一次性进程运行 进程构成（process formation）是指用来处理应用的常规业务（比如处理 web 请求）的一组进程。与此不同，开发人员经常希望执行一些管理或维护应用的一次性任务，例如：</p>\n<ul>\n<li>\n<p>运行数据移植（Django 中的 manage.py migrate, Rails 中的 rake db:migrate）。</p>\n</li>\n<li>\n<p>运行一个控制台（也被称为 REPL shell），来执行一些代码或是针对线上数据库做一些检查。大多数语言都通过解释器提供了一个 REPL 工具（ python 或 perl） ，或是其他命令（Ruby 使用 irb, Rails 使用 rails console）。</p>\n</li>\n<li>\n<p>运行一些提交到代码仓库的一次性脚本。</p>\n</li>\n</ul>\n<p>一次性管理进程应该和正常的 常驻进程 使用同样的环境。这些管理进程和任何其他的进程一样使用相同的 代码 和 配置 ，基于某个 发布版本 运行。后台管理代码应该随其他应用程序代码一起发布，从而避免同步问题。 所有进程类型应该使用同样的 依赖隔离 技术。例如，如果Ruby的web进程使用了命令 bundle exec thin start ，那么数据库移植应使用 bundle exec rake db:migrate 。同样的，如果一个 Python 程序使用了 Virtualenv，则需要在运行 Tornado Web 服务器和任何 manage.py 管理进程时引入 bin/python 。 12-factor 尤其青睐那些提供了 REPL shell 的语言，因为那会让运行一次性脚本变得简单。在本地部署中，开发人员直接在命令行使用 shell 命令调用一次性管理进程。在线上部署中，开发人员依旧可以使用ssh或是运行环境提供的其他机制来运行这样的进程。</p>\n","path":"/pages/云原生应用的12要素.html","name":"云原生应用的12要素"},{"profile":{"date":"2024-10-09","category":"学习拓展","tag":["锁","线程"]},"htmlContent":"<p><img src=\"./.assets/%E9%94%81/%E9%94%81-1728448343927.png\" alt=\"img.png\"></p>\n","path":"/pages/常用分布式锁方案中间件整理.html","name":"常用分布式锁方案中间件整理"},{"profile":{"date":"2024-10-09","category":"项目管理","tag":["开发工作流程"]},"htmlContent":"<h3>上线生产整体流程：</h3>\n<ol>\n<li>信息同步</li>\n<li>分支管理，提交审核、代码review、环境发布</li>\n<li>自动化测试，测试用例分层，功能测试，基础测试</li>\n<li>生产发布行事历，SQL、配置、镜像更新步骤</li>\n</ol>\n<h3>后端研发避坑指南</h3>\n<ol>\n<li>通用流程\n<ul>\n<li>需求沟通</li>\n<li>接口文档设计</li>\n<li>开发&amp;自测&amp;联调</li>\n<li>测试&amp;修复bug</li>\n<li>上线</li>\n</ul>\n</li>\n<li>技术思考点\n<ul>\n<li>对于重要业务(如订购、退订、支付等核心业务)，是否需要保存上下文信息，异常监控通知；保存上下文信息：打印日志、存入mysql、redis等存储中间件, 邮件报警等</li>\n<li>对于高频、分布式场景，是否需要引入限流、分布式锁、幂等、保障业务安全</li>\n<li>限流，建议使用分布式限流，如springcloud-alibaba的Sentinel、redis+lua、nginx的rete-limiting</li>\n<li>分布式锁：锁的粒度是否经过评估，精确到资源、租户、行为？锁的实现，建议使用redission</li>\n<li>幂等：针对MQ消息监听、订购、退订等场景，需要保证幂</li>\n<li>对外接口是否需要鉴权，鉴权逻辑是否经过有效评估</li>\n</ul>\n</li>\n</ol>\n","path":"/pages/开发工作流程思考.html","name":"开发工作流程思考"},{"profile":{"date":"2024-10-09","category":"学习拓展","tag":["架构设计"]},"htmlContent":"<h3>分布式架构的设计：</h3>\n<ol>\n<li>业务流程，功能模块的划分</li>\n<li>分布式事务、一致性处理、锁</li>\n<li>分支、依赖管理</li>\n<li>分库、缓存设计</li>\n</ol>\n<h3>有个叫做Eric Raymond的人，章，叫《大教堂与集市》，总结了Linux的成功之道，我建议你好好看看:</h3>\n<ol>\n<li>好软件都源自解决开发者的切身之痛。</li>\n<li>把用户当作开发伙伴，是快速改进代码和有效调试的不二法门。</li>\n<li>早发布，常发布。并听取用户意见。</li>\n<li>有这么多双眼睛看着，Bug无处可藏。</li>\n<li>精巧的数据结构即使搭配笨拙的程序代码，也比精巧代码加笨拙结构的组合要强得多</li>\n<li>保持项目的简单性。设计达到完美的时候，不是无法再增加东西了，而是无法再减少东西了。</li>\n</ol>\n","path":"/pages/系统架构设计.html","name":"系统架构设计"},{"profile":{"date":"2024-10-06","category":"学习拓展","tag":["IO","select","epoll"]},"htmlContent":"<h3><strong>1. 阻塞IO模型</strong></h3>\n<p><img src=\"@Img_IO/2024-07-08-17-29-41-image.png\" alt=\"\"></p>\n<p>进程发起IO系统调用后，进程被阻塞，转到内核空间处理，整个IO处理完毕后返回进程。操作成功则进程获取到数据。</p>\n<p><strong>1、典型应用：阻塞socket、Java BIO；</strong></p>\n<p><strong>2、特点：</strong></p>\n<ul>\n<li>进程阻塞挂起不消耗CPU资源，及时响应每个操作；</li>\n<li>实现难度低、开发应用较容易；</li>\n<li>适用并发量小的网络应用开发；</li>\n</ul>\n<p>不适用并发量大的应用：因为一个请求IO会阻塞进程，所以，得为每请求分配一个处理进程（线程）以及时响应，系统开销大。</p>\n<h3><strong>2. 非阻塞IO模型</strong></h3>\n<p><img src=\"@Img_IO/2024-07-08-17-29-47-image.png\" alt=\"\"></p>\n<p>进程发起IO系统调用后，如果内核缓冲区没有数据，需要到IO设备中读取，进程返回一个错误而不会被阻塞；进程发起IO系统调用后，如果内核缓冲区有数据，内核就会把数据返回进程。</p>\n<p>对于上面的阻塞IO模型来说，内核数据没准备好需要进程阻塞的时候，就返回一个错误，以使得进程不被阻塞。</p>\n<p>1、典型应用：socket是非阻塞的方式（设置为NONBLOCK）</p>\n<p>2、特点：</p>\n<ul>\n<li>进程轮询（重复）调用，消耗CPU的资源；</li>\n<li>实现难度低、开发应用相对阻塞IO模式较难；</li>\n<li>适用并发量较小、且不需要及时响应的网络应用开发；</li>\n</ul>\n<h3>3. <strong>IO复用模型</strong></h3>\n<p><img src=\"@Img_IO/2024-07-08-17-29-56-image.png\" alt=\"\"></p>\n<p>多个的进程的IO可以注册到一个复用器（select）上，然后用一个进程调用该select， select会监听所有注册进来的IO；</p>\n<p>如果select没有监听的IO在内核缓冲区都没有可读数据，select调用进程会被阻塞；而当任一IO在内核缓冲区中有可数据时，select调用就会返回；</p>\n<p>而后select调用进程可以自己或通知另外的进程（注册进程）来再次发起读取IO，读取内核中准备好的数据。</p>\n<p>可以看到，多个进程注册IO后，只有另一个select调用进程被阻塞。</p>\n<p>1、典型应用：select、poll、epoll三种方案，nginx都可以选择使用这三个方案;Java NIO;</p>\n<p>2、特点：</p>\n<ul>\n<li>专一进程解决多个进程IO的阻塞问题，性能好；Reactor模式;</li>\n<li>实现、开发应用难度较大；</li>\n<li>适用高并发服务应用开发：一个进程（线程）响应多个请求；</li>\n</ul>\n<p>3、select、poll、epoll</p>\n<ul>\n<li>Linux中IO复用的实现方式主要有select、poll和epoll：</li>\n<li>Select：注册IO、阻塞扫描，监听的IO最大连接数不能多于FD_SIZE；</li>\n<li>Poll：原理和Select相似，没有数量限制，但IO数量大扫描线性性能下降；</li>\n<li>Epoll ：事件驱动不阻塞，mmap实现内核与用户空间的消息传递，数量很大，Linux2.6后内核支持；</li>\n</ul>\n<h3>4. <strong>信号驱动IO模型</strong></h3>\n<p><img src=\"@Img_IO/2024-07-08-17-53-52-image.png\" alt=\"\"></p>\n<p>当进程发起一个IO操作，会向内核注册一个信号处理函数，然后进程返回不阻塞；当内核数据就绪时会发送一个信号给进程，进程便在信号处理函数中调用IO读取数据。</p>\n<p>特点：回调机制，实现、开发应用难度大；</p>\n<h3>5. <strong>异步IO模型</strong></h3>\n<p><img src=\"@Img_IO/2024-07-08-17-30-06-image.png\" alt=\"\"></p>\n<p>当进程发起一个IO操作，进程返回（不阻塞），但也不能返回果结；内核把整个IO处理完后，会通知进程结果。如果IO操作成功则进程直接获取到数据。</p>\n<p>1、典型应用：JAVA7 AIO、高性能<a href=\"https://cloud.tencent.com/act/pro/promotion-cvm?from_column=20065&amp;from=20065\">服务器</a>应用</p>\n<p>2、特点：</p>\n<ul>\n<li>不阻塞，数据一步到位；Proactor模式；</li>\n<li>需要操作系统的底层支持，LINUX 2.5 版本内核首现，2.6 版本产品的内核标准特性；</li>\n<li>实现、开发应用难度大；</li>\n<li>非常适合高性能高并发应用；</li>\n</ul>\n<p><img src=\"@Img_IO/2024-07-08-17-56-27-image.png\" alt=\"\"></p>\n<p><img src=\"@Img_IO/2024-07-08-17-31-21-image.png\" alt=\"\"></p>\n<p><img src=\"@Img_IO/2024-07-08-18-09-13-image.png\" alt=\"\"></p>\n<p><img src=\"@Img_IO/2024-07-09-09-23-09-image.png\" alt=\"\"></p>\n","path":"/pages/IO模型.html","name":"IO模型"},{"profile":{"date":"2024-10-06","category":"学习拓展","tag":["分布式一致性算法","raft"]},"htmlContent":"<h1><strong>一、Raft 概述</strong></h1>\n<p>Raft 算法是分布式系统开发首选的共识算法。比如现在流行 Etcd、Consul。</p>\n<p>如果掌握了这个算法，就可以较容易地处理绝大部分场景的容错和一致性需求。比如分布式配置系统、分布式 NoSQL 存储等等，轻松突破系统的单机限制。</p>\n<p><strong>Raft 算法是通过一切以领导者为准的方式，实现一系列值的共识和各节点日志的一致。</strong></p>\n<h1><strong>二、Raft 角色</strong></h1>\n<p><strong>2.1 角色</strong></p>\n<p><strong>跟随者（Follower）</strong>：普通群众，默默接收和来自领导者的消息，当领导者心跳信息超时的时候，就主动站出来，推荐自己当候选人。</p>\n<p><strong>候选人（Candidate）</strong>：候选人将向其他节点请求投票 RPC 消息，通知其他节点来投票，如果赢得了大多数投票选票，就晋升当领导者。</p>\n<p><strong>领导者（Leader）</strong>：霸道总裁，一切以我为准。处理写请求、管理日志复制和不断地发送心跳信息，通知其他节点“我是领导者，我还活着，你们不要”发起新的选举，不用找新领导来替代我。</p>\n<p>如下图所示，分别用三种图代表跟随者、候选人和领导者。</p>\n<p>角色</p>\n<h1><strong>三、单节点系统</strong></h1>\n<p><strong>3.1 数据库服务器</strong></p>\n<p>现在我们想象一下，有一个单节点系统，这个节点作为数据库服务器，且存储了一个值为 X。</p>\n<p>数据库服务器</p>\n<p><strong>3.2 客户端</strong></p>\n<p>左边绿色的实心圈就是客户端，右边的蓝色实心圈就是节点 a（Node a）。Term 代表任期，后面会讲到。</p>\n<p>客户端</p>\n<p><strong>3.3 客户端向服务器发送数据</strong></p>\n<p>客户端向单节点服务器发送了一条更新操作，设置数据库中存的值为 8。单机环境下（单个服务器节点），客户端从服务器拿到的值也是 8。一致性非常容易保证。</p>\n<p>客户端向服务器发送数据</p>\n<p><strong>3.4 多节点如何保证一致性？</strong></p>\n<p>但如果有多个服务器节点，怎么保证一致性呢？比如有三个节点：a，b，c。如下图所示。这三个节点组成一个数据库集群。客户端对这三个节点进行更新操作，如何保证三个节点中存的值一致？这个就是分布式一致性问题。Raft 算法就是来解决这个问题的。当然还有其他协议也可以保证，本篇只针对 Raft 算法。</p>\n<p>在多节点集群中，在节点故障、分区错误等异常情况下，Raft 算法如何保证在同一个时间，集群中只有一个领导者呢？下面就开始讲解 Raft 算法选举领导者的过程。</p>\n<h1><strong>四、选举领导过程</strong></h1>\n<p><strong>4.1 初始状态</strong></p>\n<p>初始状态下，集群中所有节点都是跟随者的状态。</p>\n<p>如下图所示，有三个节点(Node) a、b、c，任期（Term）都为 0。</p>\n<p>初始状态</p>\n<p><strong>4.2 成为候选者</strong></p>\n<p>Raft 算法实现了随机超时时间的特性，每个节点等待领导者节点心跳信息的超时时间间隔是随机的。比如 A 节点等待超时的时间间隔 150 ms，B 节点 200 ms，C 节点 300 ms。那么 a 先超时，最先因为没有等到领导者的心跳信息，发生超时。如下图所示，三个节点的超时计时器开始运行。</p>\n<p>超时时间</p>\n<p>当 A 节点的超时时间到了后，A 节点成为候选者，并增加自己的任期编号，Term 值从 0 更新为 1，并给自己投了一票。</p>\n<ul>\n<li>\n<p>Node A：Term = 1, Vote Count = 1。</p>\n</li>\n<li>\n<p>Node B：Term = 0。</p>\n</li>\n<li>\n<p>Node C：Term = 0。</p>\n</li>\n</ul>\n<p>成为候选者</p>\n<p><strong>4.3 投票</strong></p>\n<p>我们来看下候选者如何成为领导者的。</p>\n<p>Leader 选举</p>\n<ul>\n<li>第一步</li>\n</ul>\n<p>：节点 A 成为候选者后，向其他节点发送请求投票 RPC 信息，请它们选举自己为领导者。</p>\n<ul>\n<li>第二步</li>\n</ul>\n<p>：节点 B 和 节点 C 接收到节点 A 发送的请求投票信息后，在编号为 1 的这届任期内，还没有进行过投票，就把选票投给节点 A，并增加自己的任期编号。</p>\n<ul>\n<li>第三步</li>\n</ul>\n<p>：节点 A 收到 3 次投票，得到了大多数节点的投票，从候选者成为本届任期内的新的领导者。</p>\n<ul>\n<li>第四步</li>\n</ul>\n<p>：节点 A 作为领导者，固定的时间间隔给 节点 B 和节点 C 发送心跳信息，告诉节点 B 和 C，我是领导者，组织其他跟随者发起新的选举。</p>\n<ul>\n<li>第五步</li>\n</ul>\n<p>：节点 B 和节点 C 发送响应信息给节点 A，告诉节点 A 我是正常的。</p>\n<p><strong>4.4 任期</strong></p>\n<p>英文单词是 term，领导者是有任期的。</p>\n<ul>\n<li>自动增加</li>\n</ul>\n<p>：跟随者在等待领导者心跳信息超时后，推荐自己为候选人，会增加自己的任期号，如上图所示，节点 A 任期为 0，推举自己为候选人时，任期编号增加为 1。</p>\n<ul>\n<li>更新为较大值</li>\n</ul>\n<p>：当节点发现自己的任期编号比其他节点小时，会更新到较大的编号值。比如节点 A 的任期为 1，请求投票，投票消息中包含了节点 A 的任期编号，且编号为 1，节点 B 收到消息后，会将自己的任期编号更新为 1。</p>\n<ul>\n<li>恢复为跟随者</li>\n</ul>\n<p>：如果一个候选人或者领导者，发现自己的任期编号比其他节点小，那么它会立即恢复成跟随者状态。这种场景出现在分区错误恢复后，任期为 3 的领导者受到任期编号为 4 的心跳消息，那么前者将立即恢复成跟随者状态。</p>\n<ul>\n<li>拒绝消息</li>\n</ul>\n<p>：如果一个节点接收到较小的任期编号值的请求，那么它会直接拒绝这个请求，比如任期编号为 6 的节点 A，收到任期编号为 5 的节点 B 的请求投票 RPC 消息，那么节点 A 会拒绝这个消息。</p>\n<p><strong>4.5 选举规则</strong></p>\n<ul>\n<li>\n<p>一个任期内，领导者一直都会领导者，直到自身出现问题（如宕机），或者网络问题（延迟），其他节点发起一轮新的选举。</p>\n</li>\n<li>\n<p>在一次选举中，每一个服务器节点最多会对一个任期编号投出一张选票，投完了就没了。</p>\n</li>\n</ul>\n<p><strong>4.6 大多数</strong></p>\n<p>假设一个集群由 N 个节点组成，那么大多数就是至少 N/2+1。例如：3 个节点的集群，大多数就是 2。</p>\n<p><strong>4.7 心跳超时</strong></p>\n<p>为了防止多个节点同时发起投票，会给每个节点分配一个随机的选举超时时间。这个时间内，节点不能成为候选者，只能等到超时。比如上述例子，节点 A 先超时，先成为了候选者。这种巧妙的设计，在大多数情况下只有一个服务器节点先发起选举，而不是同时发起选举，减少了因选票瓜分导致选举失败的情况。</p>\n<p>成为候选者</p>\n<h1><strong>五、领导者故障</strong></h1>\n<p>如果领导者节点出现故障，则会触发新的一轮选举。如下图所示，领导者节点 A 发生故障，节点 B 和 节点 C 就会重新选举 Leader。</p>\n<p>领导者故障</p>\n<ul>\n<li>第一步</li>\n</ul>\n<p>：节点 A 发生故障，节点 B 和节点 C 没有收到领导者节点 A 的心跳信息，等待超时。</p>\n<ul>\n<li>第二步</li>\n</ul>\n<p>：节点 C 先发生超时，节点 C 成为候选人。</p>\n<ul>\n<li>第三步</li>\n</ul>\n<p>：节点 C 向节点 A 和节点 B 发起请求投票信息。</p>\n<ul>\n<li>第四步</li>\n</ul>\n<p>：节点 C 响应投票，将票投给了 C，而节点 A 因为发生故障了，无法响应 C 的投票请求。</p>\n<ul>\n<li>第五步</li>\n</ul>\n<p>：节点 C 收到两票（大多数票数），成为领导者。</p>\n<ul>\n<li>第六步</li>\n</ul>\n<p>：节点 C 向节点 A 和 B 发送心跳信息，节点 B 响应心跳信息，节点 A 不响应心跳信息，因为 A 故障了。</p>\n<h1><strong>总结</strong></h1>\n<p>Raft 算法通过以下几种方式来进行领导选举，保证了一个任期只有一位领导，极大减少了选举失败的情况。</p>\n<ul>\n<li>\n<p>任期</p>\n</li>\n<li>\n<p>领导者心跳信息</p>\n</li>\n<li>\n<p>随机选举超时时间</p>\n</li>\n<li>\n<p>先来先服务的投票原则</p>\n</li>\n<li>\n<p>大多数选票原则</p>\n</li>\n</ul>\n","path":"/pages/Raft.html","name":"Raft"},{"profile":{"date":"2024-10-06","category":"学习拓展","tag":["进程","线程","协程"]},"htmlContent":"<h3>进程切换开销</h3>\n<ol>\n<li>直接开销•\n<ul>\n<li>切换页表全局目录（PGD）</li>\n<li>切换内核态堆栈</li>\n<li>切换硬件上下文（进程恢复前，必须装入寄存器的数据统称为硬件上下文）</li>\n<li>刷新TLB</li>\n<li>系统调度器的代码执行</li>\n</ul>\n</li>\n<li>间接开销\n<ul>\n<li>CPU 缓存失效导致的进程需要到内存直接访问的IO 操作变多</li>\n</ul>\n</li>\n</ol>\n<h3>线程切换开销</h3>\n<ul>\n<li>线程本质上只是一批共享资源的进程，线程切换本质上依然需要内核进行进程切换</li>\n<li>一组线程因为共享内存资源，因此一个进程的所有线程共享虚拟地址空间</li>\n<li>线程切换相比进程切换，主要节省了虚拟地址空间的切换</li>\n</ul>\n<h3>协程切换开销</h3>\n<p>用户线程无需内核帮助，应用程序在用户空间创建的可执行单元，创建销毁完全在用户态完成</p>\n","path":"/pages/进程_线程_协程.html","name":"进程_线程_协程"}]